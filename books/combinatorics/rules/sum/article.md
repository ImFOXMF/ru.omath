## Разделяй и складывай

Во время решения комбинаторных задач не раз и не два будет вставать вопрос: как определить количество способов взять один объект из нескольких групп объектов?
Отличной иллюстрацией такого вопроса служит следующий пример:

{ #example1 }
@example
    title: Вечернее платье
    task: |
        Настя собирается в театр и пытается выбрать подходящее платье.
        У нее есть $3$ черных и $2$ белых платья.
        Сколько у нее вариантов выбрать одно платье для театра?
    solution: |
        Все платья разбиты на $2$ группы или класса: черные и белые.
        У Насти есть $3$ способа выбрать одно черное платье (взять одно из трех) и $2$ способа выбрать одно белое платье (взять одно из двух).
        Всего получается $3 + 2 = 5$ способов выбрать платье для театра, то есть совершить выбор "черное или белое платье".

В этой задаче объекты (платья) разбиты на два класса (черные и белые).
Для выяснения общего количества вариантов мы просто складываем количество объектов в этих двух классах.
Разделение на классы и сложение работает не только для двух, а вообще для любого количества групп или классов.

{ #example2 }
@example
    title: Фрукты на закуску
    task: |
        На столе лежит $5$ яблок, $3$ апельсина и $8$ бананов.<br>
        Сколько существует способов выбрать хоть какой-то из этих фруктов?
    solution: |
        У нас есть три группы фруктов: яблоки, апесльины и бананы.
        Есть $5$ способов выбрать себе яблоко, $3$ способа выбрать апельсин и $8$ вариантов выбрать банан.
        Тогда суммарно имеем $5+3+8 = 16$ вариантов выбрать хоть какой-то фрукт.
        Еще можно сказать, что у нас есть $16$ вариантов выбрать "Яблоко или Апельсин или Банан".

## Но есть нюанс

Обратите внимание, что в рассмотренных примерах классы отделены друг от друга.
То есть в них нет таких объектов, которые принадлежат сразу нескольким классам.
Не может быть одновременно черного и белого платья.
Не может яблоко быть апельсином или бананом.

Но классы не всегда бывают такими удобными.
Поэтому надо следить, чтобы они не пересекались друг с другом.
Если же забыть сделать проверку, то может получится что-то такое:

@example:
    title: Обманчивые детские игрушки
    task: |
        В магазине детских игрушек есть $6$ кубиков, $3$ из которых синего цвета и $5$ шариков синего цвета.
        Сколькими способами можно сделать выбор "Кубик или синяя игрушка"?
    solution: |
        Итак, у нас есть два класса объектов: "Кубики" и "Синие игрушки".
        Посчитаем, сколько объектов лежат в каждой из этих групп.
        Кубик можно выбрать $6$ способами. Синюю игрушку можно выбрать $8$ способами ($3$ кубика и $5$ шариков).
        Выходит, выбор "Кубик или синяя игрушка" можно сделать $6 + 8 = 14$ способами!
        Элементарно, Ватсон!

Но это неправильный ответ.
Дело в том, что группы "Кубик" и "Синяя игрушка" пересекаются друг с другом, потому что в магазине есть $3$ игрушки, которые **одновременно** являются и кубиком, и синей игрушкой. Три этих кубика есть в группе "Кубик", но эти же три кубика есть и в группе "Синяя игрушка". Когда мы сложили эти две группы, мы лишний раз учли эти три кубика.

@image
    src: assets/duplicate.svg
    caption: Возникновение дубликатов при делении на группы.
    width:
        full: 500px

Для получения правильного ответа достаточно вычесть эти три кубика, которые мы учли лишний раз: $6 + 8 - 3 = 11$.
Всего $11$ способов выбрать "Кубик или синюю игрушку".

В примерах выше классы были сформулированы уже в условии.
В более сложных задачах этим придется заниматься уже вам, как и следить за тем, чтобы они не пересекались.
Об этом не стоит забывать.

{ #check-intersections }
@important
    title: Проверяйте пересечения!
    content: |
        Применяя правило суммы всегда проверяйте классы на пересечение!
        В элементарных задачах очень просто заметить объекты, принадлежащие сразу к нескольким классам, но в более сложных глаз может замылиться!

## Правило сложения

Мы рассмотрели достаточно примеров, чтобы обнаружить закономерность.
[Отвлекаясь от смысла](@article|combinatorics/preface|i:meaning), мы сначала разбиваем объекты на **непересекающиеся** классы.
А потом просто **складываем** количество объектов в этих классах.
Так и получаем количество способов выбрать объект из этих классов.

{ #rule-of-sum }
@definition
    title: Правило сложения
    content: |
        Если объект из класса $A$ можно выбрать $a$ способами, а объект из класса $B$ можно выбрать $b$ способами, то выбор "$A$ или $B$" можно осуществить $a+b$ способами при условии, что эти классы не пересекаются.

{ #sum-rule-usage }
Правило сложения (или правило суммы) позволяет разбивать сложную задачу на несколько более легких подзадач.
Получив ответы на эти более легкие подзадачи их останется только сложить вместе и автоматом получить ответ на исходную сложную задачу!

{ #intersections }
@important
    content: |
        Если при применении правила сложения два класса все же пересекаются, то есть имеют одинаковые элементы, то формула приобретает вид $a+b-p$, где $p$ -- число пересечений.

Не всегда правило сложения можно применить так легко и просто, как в рассмотренных выше примерах.
Иногда нужно догадаться, как его надо использовать.
Если все было бы тривиально, математика была бы слишком скучной, не так ли?

{ #point-journey }
@example
    title: Точечное путешествие
    task: |
        Турист находится в городе $A$.
        Попасть он хочет в город $E$.
        Двигаться он может только по стрелкам.
        Не используя прямого перебора найдите, сколько всего есть разных маршрутов из $A$ в $E$.

        @image
            src: assets/inverse-vector-roads.svg
            width:
                full: 400px

    solution: |
        Так напрямую перебрать все варианты мы не можем, надо придумать что-то еще.
        Попробуем вести рассуждения не с начальной точки $A$, а с точки назначения -- $E$.

        Попасть в $E$ можно только из точек $B$, $C$ и $D$, причем только одним способом (одной дорогой) из каждой.
        Значит, каждый способ попасть, например, в $B$ автоматом [является способом](spoiler:why-every-road) попасть и в $E$!
        Если в $B$ можно попасть, условно, $5$-ю способами, то это сразу дает $5$ способов попасть и в $E$.

        { #why-every-road }
        @spoiler
            Предположим, что в точку $B$ можно попасть $5$-ю способами.
            Из точки $B$ в $E$ ведет всего одна дорога.
            Поэтому любой из $5$-ти способов попасть в $B$, пройдя еще по одной единственной дороге, превращается в способ попасть в $E$.
            Значит, попасть в $E$ столько же способов, сколько попасть в $B$.

        Такие же рассуждения справедливы и для точек $C$ и $D$.
        Получается, все маршруты в $E$ можно разбить на $3$ класса.
        В первом классе предпоследней точкой будет $B$, во втором $C$, а в третьем $D$.
        Плюс еще и в том, что эти классы не пересекаются, ведь маршруты в них уникальные, со своей предпоследней точкой.

        Итак, вопрос о попадании в точку $E$ сводится к вопросу о всех способах попасть в "точку $B$ ИЛИ точку $C$ ИЛИ точку $D$".
        А на такие вопросы можно ответить с помощью [правила суммы](d:rule-of-sum)!
        Введем обозначение $S_E$, которое обозначает количество способов попасть в точку $E$.
        Тогда:

        $$ S_E = S_B + S_C + S_D $$

        Для точки $D$ можно применить те же рассуждения, что и для точки $E$.
        Тогда получится, что $S_D = S_B + S_C$.
        Итоговая формула для $E$ будет выглядеть так:

        $$ S_E = S_B + S_C + \underbrace{S_B + S_C}_{S_D} $$

        Попасть в $B$ из $A$ можно одним способом, то есть $S_B = 1$.
        Попасть в $C$ из $A$ можно двумя способами, то есть $S_C = 2$.
        Тогда:

        $$ S_E = 1 + 2 + 1 + 2 = 6 $$

        Всего $6$ разных маршрутов из $A$ в $E$!